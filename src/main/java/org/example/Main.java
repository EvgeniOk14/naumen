package org.example;

import java.io.*;
import java.util.*;

/**
 * Программа моделирует кэширование запросов на сервере.
 * <p>
 * Алгоритм работы:
 * 1. Генерируется файл input.txt с заданным количеством запросов (N) и общим числом запросов (M).
 * 2. В файле input.txt записываются два числа: максимальное количество запросов, которое может быть закэшировано на сервере (N),
 *    и общее количество запросов (M), разделенные пробелом и переводом строки.
 * 3. Генерируются случайные идентификаторы запросов и записываются в файл input.txt по одному в каждой строке.
 * 4. Запускается алгоритм обработки запросов:
 *    - Читается файл input.txt.
 *    - Создается кэш памяти сервера в виде коллекции LinkedHashSet.
 *    - Происходит обработка запросов:
 *      - Если запрос уже содержится в кэше, он игнорируется.
 *      - Если запроса нет в кэше:
 *        - Если размер кэша превышает максимальное количество, удаляется первый добавленный запрос.
 *        - Запрос добавляется в кэш.
 *        - Увеличивается счетчик промахов кэша.
 * 5. Результат работы алгоритма (количество промахов кэша) записывается в файл output.txt.
 * 6. Замеряется время выполнения алгоритма и выводится в консоль.
 * </p>
 */

public class Main
{
    public static void main(String[] args)
    {
        int N = 100000; // максимальное количество запросов, которое может быть закэшировано на сервере
        int M = 100000; // общее количество запросов

        try {
            FileWriter writer = new FileWriter("input.txt");
            writer.write(N + " " + M + "\n"); // записываем первую строку с двумя числами через пробел и переводом строки

            Random random = new Random();
            for (int i = 0; i < M; i++)
            {
                int requestId = random.nextInt(Integer.MAX_VALUE) + 1; // генерируем случайное целое число для идентификатора запроса
                writer.write(requestId + "\n"); // записываем идентификатор запроса с переводом строки
            }
            writer.close();
            System.out.println("Файл input1.txt создан успешно.");
        }
        catch (IOException e)
        {
            System.out.println("Ошибка при создании файла: " + e.getMessage());
        }

        try
        {
            long startTime = System.currentTimeMillis(); // замеряем время начала выполнения алгоритма

            Scanner scanner = new Scanner(new File("input1.txt")); // чтение из файла данных
            PrintWriter writer = new PrintWriter(new File("output1.txt")); // запись в файл данных


            int maxCacheSize = scanner.nextInt(); // <--- максимальное количество запросов в кэш памяти сервера
            int numRequests = scanner.nextInt(); //  <--- общее максимальное количество запросов к серверу
            scanner.nextLine(); // переход на новую строку

            Set<Integer> cache = new LinkedHashSet<>(); // имитация КЭШ памяти сервера, LinkedHashSet - хранит порядок добавления элементов
            int cacheMisses = 0; // счётчик промахов кэша (когда программа не находит идентификатор в кэш и сервер получает запрос из распределённой системы)

            for (int i = 0; i < numRequests; i++) // проходим максимальное число запросов
            {
                int requestId = scanner.nextInt(); // считываем первый элемент и присваиваем его переменной requestId
                if (!cache.contains(requestId)) // проверяем, если такого id  в кэш нет, то:
                {
                    if (cache.size() >= maxCacheSize) // если память кэш переполнена (больше максимальной), то:
                    {
                        int firstRequestId = cache.iterator().next(); // находим первый элемент в кэш
                        cache.remove(firstRequestId); // удаляем первый найденный элемент из кэш (освобождаем память)
                    }
                    cache.add(requestId); // добавляем номер id запроса в кэш
                    cacheMisses++;  // увеличиваем счётчик пропусков на один
                }
            }

            writer.println(cacheMisses); // добавляем количество пропущенных запросов в файл (для последующего анализа запросов)

            scanner.close(); // закрываем сканер
            writer.close(); // закрываем запись

            long endTime = System.currentTimeMillis(); // замеряем время окончания выполнения алгоритма
            long executionTime = endTime - startTime; // вычисляем время выполнения алгоритма

            System.out.println("Время выполнения алгоритма: " + executionTime + " миллисекунд");
        }
        catch (FileNotFoundException e) // исключение если файл не найден
        {
            e.printStackTrace(); // вывод информации об исключении в консоль
        }
    }
}